import { OAuth2Client, TokenPayload } from "google-auth-library";
import { IUserRepository } from "../../domain/repositories/IUserRepository";
import { ITokenService } from "../services/ITokenService";
import { User, UserRole } from "../../domain/entities/User";

export class GoogleLogin {
  private client: OAuth2Client;

  constructor(
    private userRepository: IUserRepository,
    private tokenService: ITokenService,
    private googleClientId: string,
    private googleClientSecret: string,
  ) {
    if (!googleClientId || !googleClientSecret) {
      throw new Error(
        "Google client ID and Secret are required for GoogleLogin use case",
      );
    }
    this.client = new OAuth2Client(
      googleClientId,
      googleClientSecret,
      "postmessage",
    );
  }

  async execute(
    code: string,
    requiredRole?: UserRole,
  ): Promise<{
    accessToken: string;
    refreshToken: string;
    user: { id: string; email: string; role: UserRole; name?: string; profileImage?: string; isBlocked: boolean };
  }> {
    console.log("GoogleLogin: Exchanging code for tokens...");
    const { tokens } = await this.client.getToken(code);
    const idToken = tokens.id_token;

    if (!idToken) {
      console.error("GoogleLogin: No ID token in response", tokens);
      throw new Error("Failed to retrieve ID token from Google");
    }

    console.log("GoogleLogin: Verifying ID token...");
    const ticket = await this.client.verifyIdToken({
      idToken,
      audience: this.googleClientId,
    });

    const payload: TokenPayload | undefined = ticket.getPayload();
    if (!payload || !payload.email) {
      console.error("GoogleLogin: Invalid payload", payload);
      throw new Error("Invalid Google token payload");
    }

    console.log("GoogleLogin: Payload verified", { email: payload.email });
    const { email, sub: googleId, name } = payload;

    if (!googleId) {
      throw new Error("Google ID(sub) missing from payload");
    }

    let user = await this.userRepository.findByGoogleId(googleId);

    if (!user) {
      //Check if user exists with the same email
      user = await this.userRepository.findByEmail(email);

      if (user) {
        // Link account if it matches email (or throw error/update)
        const updatedUser = new User(
          user.id,
          user.email,
          user.role,
          user.password,
          (user.name || name) as string | undefined,
          user.phone, // Current phone
          googleId,
          user.profileImage // Current profile image
        );

        await this.userRepository.save(updatedUser);
        user = updatedUser;
      } else {
        //Create new customer
        user = new User(
          "", //ID will be generated by DB
          email,
          "customer",
          undefined, //No password for Google users
          name,
          undefined, // No phone for new OAuth users
          googleId,
          undefined // No profile image for new OAuth users
        );

        await this.userRepository.save(user);
        //Re-fetch to get the ID if it was created
        user = await this.userRepository.findByGoogleId(googleId);
      }
    }

    if (!user) {
      throw new Error("Failed to authenticate with Google");
    }

    if (user.isBlocked) {
      throw new Error("Your account has been blocked. Please contact admin.");
    }

    // Role validation
    console.log("GoogleLogin: Verifying role", {
      requiredRole,
      userRole: user.role,
    });
    if (requiredRole && user.role !== requiredRole) {
      console.warn("GoogleLogin: Role mismatch", {
        requiredRole,
        userRole: user.role,
      });
      throw new Error("Access denied: Unauthorized role for this portal");
    }

    //Access token
    const accessToken = this.tokenService.generate(
      {
        id: user.id,
        email: user.email,
        role: user.role,
      },
      process.env.JWT_ACCESS_SECRET || "access_fallback",
      "15m",
    );

    // Refresh Token
    const refreshToken = this.tokenService.generate(
      { id: user.id },
      process.env.JWT_REFRESH_SECRET || "refresh_fallback",
      "7d",
    );

    return {
      accessToken,
      refreshToken,
      user: {
        id: user.id,
        email: user.email,
        role: user.role,
        name: user.name,
        profileImage: user.profileImage,
        isBlocked: user.isBlocked,
      },
    };
  }
}
